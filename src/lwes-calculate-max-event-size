#!/usr/bin/perl
#======================================================================
# Copyright (c) 2008, Yahoo! Inc. All rights reserved.
#
# Licensed under the New BSD License (the "License"); you may not use
# this file except in compliance with the License.  Unless required
# by applicable law or agreed to in writing, software distributed
# under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License. See accompanying LICENSE file.
#======================================================================

use strict;
use warnings;

use Data::Dumper;

if (scalar (@ARGV) < 1)
  {
    print STDERR "lwes-calculate-max-size <esf_files>\n";
    exit 1;
  }

my $events = {};

my $current_event = undef;
my $in_event = 0;
my $in_meta = 0;

my $lines = 1;
# parse the file
open (FH, "< $ARGV[0]");
while (<FH>)
  {
    my $line = $_;

    # kill leading and trailing white-space
    $line =~ s/^\s*//g;
    $line =~ s/\s*$//g;

    # skip comment lines
    next if $line =~ m/^#/;
    # skip blank lines
    next if $line eq "";

    if ($in_event)
      {
        if ($line eq "}")
          {
            $in_event = 0;
            $current_event = undef;
          }
        else
          {
	    if ($line =~ /((\w+)\s+)?(\w+)\s*(\((\d+)\))?(\[(\d+)?\])?\s+(\w+)(\s*=\s*.+?)?\s*;?\s*(#.*)?$/)
	      {
		my ($contract, $type, $array, $length, $count, $name, $defval, $comment)
		    = (defined $2 ? uc($2) : undef, $3, defined($4) ? 1 : 0, defined($4) ? $5 : 1, $7, $8, $9, $10);
                if (defined $contract
		    && $contract ne "OPTIONAL"
                    && $contract ne "REQUIRED")
                  {
                    print STDERR "ERROR: line $lines\n";
                    print STDERR "ERROR: '$contract' should be one of\n";
                    print STDERR "\tOPTIONAL\n";
                    print STDERR "\tREQUIRED\n";
                    exit 1;
                  }
                if (defined ($current_event))
                  {
                    $events->{$current_event}->{$name} =
                      {
			'name' => $name,
                        'type' => $type,
                        'contract' => $contract,
			'array' => $array,
			'count' => $count,
			'length' => $length,
                      };
                  }
              } else {
		  print STDERR "ERROR: Unable to parse line $line\n";
	      }
          }
      }
    else
      {
        if ($line eq "{")
          {
            $in_event = 1;
          }
        else
          {
            unless (exists ($events->{$line}))
              {
                $current_event = $line;
                $events->{$current_event} = { };
              }
            else
              {
                print STDERR "ERROR: line $lines\n";
                print STDERR "ERROR: $line event exists twice in file!\n";
                exit 1;
              }
          }
      }
  }
close (FH);

# calculate the sizes

# calculate meta size
my $meta_attributes_size = 0;
foreach my $attr (keys %{$events->{'MetaEventInfo'}})
  {
    # ignore fields set by the listener or journaller
    next if $attr eq "SenderIP";
    next if $attr eq "SenderPort";
    next if $attr eq "ReceiptTime";
    next if $attr eq "SiteID";
    #printf "Field %s (%s) takes up to %d bytes\n",
    #  $events->{'MetaEventInfo'}->{$attr}->{'name'},
    #  $events->{'MetaEventInfo'}->{$attr}->{'type'},
    #  $events->{'MetaEventInfo'}->{$attr}->{'length'},
    #  $events->{'MetaEventInfo'}->{$attr}->{'count'},
    #  calculateEventEntrySize ('MetaEventInfo', $events->{'MetaEventInfo'}->{$attr});
    $meta_attributes_size +=
      calculateEventEntrySize ('MetaEventInfo', $events->{'MetaEventInfo'}->{$attr});
  }

foreach my $event (keys %{$events})
  {
    next if $event eq "MetaEventInfo";
    my $event_max_size = $meta_attributes_size;
    $event_max_size += calculateEventHeaderSize ($event);
    foreach my $attr (keys %{$events->{$event}})
      {
	#printf "Field %s (%s(%d)[%d]) takes up to %d bytes\n",
	#  $events->{$event}->{$attr}->{'name'},
	#  $events->{$event}->{$attr}->{'type'},
	#  $events->{$event}->{$attr}->{'length'},
	#  $events->{$event}->{$attr}->{'count'},
	#  calculateEventEntrySize ($event, $events->{$event}->{$attr});
        $event_max_size +=
	  calculateEventEntrySize ($event, $events->{$event}->{$attr});
      }
    print "$event\t$event_max_size\n";
  }

sub calculateEventHeaderSize
{
  my ($eventname) = @_;
  my $size = 0;

  # one byte for event name length
  $size += 1;

  # length bytes for event name
  $size += length $eventname;

  # two bytes for number of attributes
  $size += 2;

  return $size;
}

sub calculateEventEntrySize
{
  my $event = shift;
  my $attr  = shift;
  my ($name,$type,$length,$count) = ($attr->{'name'},$attr->{'type'},$attr->{'length'},$attr->{'count'});

  unless (defined $count)
    {
      print STDERR "WARN: $event.$name array has no maximum count; byte count is forced to ignore it\n";
      return 0;
    }

  my $size = 0;

  # add one byte for attribute name length
  $size += 1;

  # add length bytes for attribute name
  $size += length $attr->{'name'};

  # add one byte for attribute type id
  $size += 1;

  # now add bytes for data types
  if ($type eq "boolean" || $type eq "byte")
    {
      $size += $count * 1;
    }
  elsif ($type eq "uint16" || $type eq "int16")
    {
      $size += $count * 2;
    }
  elsif ($type eq "uint32" || $type eq "int32" || $type eq "ip_addr" || $type eq "float")
    {
      $size += $count * 4;
    }
  elsif ($type eq "uint64" || $type eq "int64" || $type eq "double")
    {
      $size += $count * 8;
    }
  elsif ($type eq "string")
    {
      # two bytes of length
      $size += $count * 2;

      # add max size bytes of length
      unless (defined ($length))
        {
          print STDERR "WARN: $event.$name has no maximum length; byte count is forced to ignore it\n";
	  return 0;
        }
      if ($length > 65535)
        {
          print STDERR "WARN: $event.$name has no maximum length; byte count is forced to ignore it\n";
        }
      $size += $count * $length;
    }
  else
    {
      print STDERR "ERROR: unknown type [$type]\n";
      exit 1;
    }

  return $size;
}

exit 0;
